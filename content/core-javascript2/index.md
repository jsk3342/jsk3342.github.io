---
emoji: 🔮
title: 실행 컨텍스트
date: '2022-10-23 00:00:00'
author: 김지수
tags: 자바스크립트 core-javascript
categories: 자바스크립트
---

# 실행 컨텍스트
실행할 코드에 제공할 환경 정보들을 모아놓은 객체로, 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념입니다.자바스크립트는 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(호이스팅), 외부 환경 정보를 구성하고, this 값을 설정하는 등의 동작을 수행하는데, 이로 인해 특이한 현상들이 발생 합니다.

언어를 FPS 게임에 비유 하자면 총을 쏠 때 바람의 세기, 목표물과의 거리 등 보정이 들어가는 것 처럼 자바스크립트는 알아서 조절 되지만 C언어는 일일이 생각하여 작성해야 합니다.

이처럼 자바스크립트는 보정이 들어가기 때문에 개발자는 어떤 부분이 보정이 들어가고 보정으로 발생하는 사이드 이펙트를 파악하는 노력이 필요합니다.

## 실행 컨텍스트란?
본격적으로 알아보기 전 스택과 큐의 개념을 알아야 합니다.
두 가지 자료구조는 연속적인 데이터를 효율적으로 처리하기 위해 등장했습니다.

동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하고, 이를 콜 스택에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장합니다. 
여기서 '동일한 환경', 즉 하나의 실행 컨텍스트를 구성할 수 있는 방법으로 전역공간, eval() 함수, 함수 등이 있습니다. 자동으로 생성되는 전역공간과 eval을 제외하면 흔히 함수를 실행하는 것 입니다.

어떤 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 필요한 환경 정보들을 수집해서 실행 컨텍스트 객체에 저장합니다. 이 객체는 자스 엔진이 활용할 목적으로 생성할 뿐 개발자가 코드를 통해 확인할 수는 없습니다. 여기에 담기는 정보들은 다음과 같습니다.

- VariableEnvironment : 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경정보 선언 시점의 LexicalEnvironment의 스냅샷으로, 변경 사항은 반영되지 않음.
- LexicalEnvironment : 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨.
- ThisBinding : this 식별자가 바라봐야 할 대상 객체.

## VariableEnvironment
VariableEnvironment에 담기는 내용은 LexicalEnvironment와 같지만 최초 실행 시의 스냅샷을 유지한다는 점이 다릅니다. 실행 컨텍스트를 생성할 때 VariableEnvironment에 정보를 먼저 담은 다음, 이를 그대로 복사해서 LexicalEnvironment를 만들고, 이후에는 LexicalEnvironment를 주로 활용하게 됩니다. VariableEnvironment와 LexicalEnvironment의 내부는 environmentRecord와 outer-EnvironmentReference로 구성돼 있습니다. 

## LexicalEnvironment
environmentRecord와 outer-EnvironmentReference로 구성돼 있습니다. 
어휘의, 문맥의 라는 의미를 담고 있기에 내부 정보와 외부 환경 참조 정보가 기록된 객체 정도로 이해하면 되겠습니다. 

### environmentRecord와 호이스팅
environmentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장됩니다. 컨텍스트를 구성하는 함수에 지정된 매개변수 식별자, 선언한 함수가 있을 경우 그 함수 자체, var로 선언된 변수의 식별자 등이 식별자에 해당합니다. 컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며 순서대로 수집합니다.
변수 정보를 수집하는 과정을 모두 마쳤더라도 아직 실행 컨텍스트가 관여할 코드들은 실행되기 전의 상태입니다. 코드가 실행되기 전임에도 불구하고 엔진은 이미 해당 환경에 속한 코드의 변수명들을 모두 알고 있습니다. 그렇다면 엔진의 실제 동작 방식 대신에 '엔진은 식별자들을 최상단으로 끌어올려놓은 다음 실제 코드를 실행한다'라고 생각하여 호이스팅이라는 개념이 등장합니다. 끌어올리다는 의미로 변수 정보를 수집하는 과정을 더욱 이해하기 쉬운 방법으로 대체한 가상의 개념입니다. 실제로 끌어올리지는 않지만 편의상 끌어올린 것으로 간주하자는 것이죠.

이러한 방식이 끌어올린다는 표현 보다 변수 호출 준비를 마쳤다는 의미로 저는 장전, 또는 준비완료 reload 라고 하고 싶은데 사회적으로 약속된 호이스팅이라는 표현으로 설명하겠습니다.

### 스코프 
스코프란 식별자에 대한 유효범위입니다. ES5까지의 자스는 오직 함수에 의해서만 스코프가 생성됩니다. 식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해나가는 것을 스코프 체인이라고 합니다.

### 스코프 체인 
outerEnvironmentReference는 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조합니다.



## QNA

### 실행 컨텍스트란?
인터프리터 언어로 순차적으로 코드가 실행 될 때 코드의 실행 범위나 기준에 맞춰 동작해야 하는데 실행할 코드에 제공할 환경 정보들을 담고 있는 객체 입니다.

### 호이스팅이란?


### var let const 차이?
var는 재 선언과 재 할당이 가능합니다.
let은 재 할당으 가능 재선언 불가
const는 한 번만 가능합니다.

### 콜 스택이란?
자바스크립트 코드가 실행되며 생성하는 실행 컨텍스트를 저장하는 자료구조입니다.

### 이벤트 루프에 대해서 설명 콜 스택을 사용하여
이벤트 루프는 싱글 쓰레드인 자바스크립트를 비동기 처리 하기 위해 브라우저와 노드 환경에서 작동하게 됩니다. 함수 실행을 기점으로 콜 스택에 실행 컨텍스트들이 쌓이게 되고 나중에 들어간 컨텍스트가 제일 먼저 나오면서 코드를 처리하게 됩니다. 이때 콜백 함수나 비동기 함수들을 만나게 되면 웹 API에서 대기 후 실행이 완료되면 테스크 큐에 준비하고 있다가 콜 스택이 비워지게 되면 테스크 큐에서 콜 스택으로 이동하여 코드가 실행되게 됩니다.

### 마이크로 테스크 큐

### 메크로 테스크 큐

### 스코프 블록, 함수 차이

### 렉시컬 스코프?

### var를 안쓰는 이유?

### 함수 선언문, 표현식 차이와 함수 표현식을 선호하는 이유?
둘 다 함수를 새롭게 정의할 때 쓰이는 방식인데, 그중 함수 선언문은 function 정의부만 존재하고 별도의 할당 명령이 없는것을 의미합니다.
표현식은 저의한 function을 별도의 변수에 할당하는 것을 말합니다.
선언문의 경우 반드시 함수명이 정의돼 있어야 하는 반면, 표현식은 없어도 됩니다.

실질적인 차이는 호이스팅에 있습니다. 
선언문은 전체를 호이스팅하고 표현식은 선언부만 끌어 올립니다.

다량의 코드에서 의도치않게 동명의 함수를 작성하게 되어 선언문으로 작성하게 되면 나중에 할당된 값이 이전 값을 덮어씌우기 때문에 디버깅에 어려움이 발생합니다.
