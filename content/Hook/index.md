---
emoji: 🚀
title: Hook이란?
date: '2022-10-18 00:00:00'
author: 김지수
tags: 리액트 react Hook
categories: react
---

# Hook은 뭘까? 왜 나왔을까?
리액트 16.8.0부터 훅을 처음으로 지원하게 되었습니다. 리액트에서는 왜 훅을 만들었고 어떤 원리를 차용하고 있을까요?

리액트는 클래스를 제거할 계획은 없습니다.
훅은 리액트 컨셉을 대체하지 않습니다. - 기존 컨셉은 뭘까요?

## Hook의 등장 배경
5년간 React로 컴포넌트를 작성하고 유지하는 동안 부딪혔던 수 많은 문제들을 해결했습니다. 

1. 컴포넌트 사이에서 상태 로직을 재사용하기 어렵습니다.
    컴포넌트간에 재사용 가능한 로직을 붙이는 방법을 제공하지 않습니다. 이전부터 리액트를 사용해왔다면 render props나 고차 컴포넌트와 같은 패턴을 통해 이러한 문제를 해결하는 방법에 익술할 것입니다. 그러나 이런 패턴의 사용은 컴포넌트의 재구성을 강요하며, 코드의 추적을 어렵게 만듭니다. React 개발자 도구에서 다른 추상화에 대한 레이어로 둘러싸인 래퍼지옥을 볼 가능성이 높습니다. 개발자 도구에서 걸러낼 수 있지만, 이 문제의 요점은 상태 관련 로직을 공유하기 위해 좀 더 좋은 기초 요소가 필요했습니다.

    훅을 사용하면 컴포넌트로부터 상태 관련 로직을 추상화할 수 있습니다. 이를 통해 독립적인 테스트와 재사용이 가능합니다. Hook은 계층의 변화 없이 상태 관련 로직을 재사용할 수 있도록 도와줍니다.

2. 복잡한 컴포넌트들은 이해하기 어렵습니다. 
    관리하기 힘들어지는 상태 관련 로직들과 사이드 이펙트가 있는 컴포넌트를 유지보수 해야 합니다. 각 생명주기 메서드에는 자주 관련 없는 로직이 섞여들어가고는 합니다. 예시로 componentDidMount 와 componentDidUpdate는 컴포넌트안에서 데이터를 가져오는 작업을 수행할 때 사용 되어야 하지만, 같은 componentDidMount에서 이벤트 리스너를 설정하는 것과 같은 관계없는 로직이 포함되기도 하며, componentWillUnmount에서 cleanup 로직을 수행하기도 합니다. 함께 변경되는 상호 관련 코드는 분리되지만 이와 연관 없는 코드들은 단일 메서드로 결합합니다. 이로 인해 버그가 쉽게 발생하고 무결성을 너무나 쉽게 해칩니다.

    상태 관련 로직은 한 공간안에 묶여 있기 때문에 이런 컴포넌트들을 작게 분리하는 것은 불가능하며 테스트하기도 어렵습니다. 이와 같은 문제를 해결하기 위해 생명주기 메서드를 기반으로 쪼개는 것 보다는, Hook을 통해 서로 비슷한 것을 하는 작은 함수의 묶음으로 컴포넌트를 나누는 방법을 사용할 수 있습니다.
    
3. 클래스는 어렵습니다.
    Class 사용을 위해서는 자바스크립트의 this 키워드가 어떻게 작동하는지 알아야합니다. 대부분의 다른 언어에서와는 다르게 작동하여 큰 혼란을 주고 코드의 재사용성과 구성을 매우 어렵게 만들고는 했습니다. 훅은 클래스 없이 리액트 기능들을 사용하는 방법을 제시합니다. 개념적으로 컴포넌트는 함수에 더 가깝습ㄴ다. 훅은 함수의 사용을 권장합니다. 명령형 코드로 해결책을 찾을 수 있게 해주며 복잡한 함수형 또는 반응형 프로그래밍 기술을 배우도록 요구하지 않습니다.

## State Hook
```
import React, { useState } from 'react';

function Example() {
  // "count"라는 새 상태 변수를 선언합니다
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```
여기서 useState가 바로 Hook 입니다. 훅을 호출해 함수 컴포넌트 안에 state를 추가했습니다. 이 state는 컴포넌트가 다시 렌더링 되어도 그대로 유지될 것입니다. useState는 현재의 state 값과 이 값을 업데이트 하는 함수를 쌍으로 제공합니다. 우리는 이 함수를 이벤트 핸들러나 다른 곳에서 호출할 수 있습니다. 이것은 class의 this.setState와 거의 유사하지만, 이전 state와 새로운 state를 합치지 않는다는 차이점이 있습니다. 
- 클래스 this.setState 알아보기

useState는 초기 state 값을 하나 받습니다. 카운터는 0부터 시작하기 때문에 위 예시에서는 초기값으로 0을 넣어준 것입니다. this.state 와 달리 useState Hook의 state는 객체일 필요가 없습니다. 이 초기값은 첫 번째 렌더링에만 딱 한번 사용됩니다.

### 여러 state 변수 선언하기
하나의 컴포넌트 내에서 State Hook을 여러 개 사용할 수도 있습니다.

```
function ExampleWithManyStates() {
  // 상태 변수를 여러 개 선언했습니다!
  const [age, setAge] = useState(42);
  const [fruit, setFruit] = useState('banana');
  const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);
  // ...
}
```
배열 구조 분해 문법은 useState 변수들을 다른 변수명으로 할당할 수 있게 해줍니다. 

### 훅이란?
훅은 함수 컴포넌트에서 React state와 생명주기 기능을 연동할 수 있게 해주는 함수입니다. Hook은 class 안에서는 동작하지 않습니다. 대신 class 없이 React를 사용할 수 있게 해주는 것입니다. React는 useState 같은 내장 Hook을 몇 가지 제공합니다. 컴포넌트 간에 상태 관련 로직을 재사용하기 위해 Hook을 직접 만드는 것도 가능합니다. 일단 내장 훅 먼저 보겠습니다.

## Effect Hook
컴포넌트 안에서 데이터를 가져오거나 구독하고, DOM을 직접 조작하는 작업을 이전에도 종종 해보셨을 것입니다. 우리는 이런 모든 동작을 "side effects"라고 합니다. 왜나면 이것은 다른 컴포넌트에 영향을 줄 수도 있고, 렌더링 과정에서는 구현할 수 없는 작업이기 때문입니다.

useEffect는 함수 컴포넌트 내에서 이런 side effects를 수행할 수 있게 해줍니다. React class의 componentDidMount나 componentDidUpdate, componentWillUnmount와 같은 목적으로 제공되지만, 하나의 API로 통합된 것입니다.

useEffect를 사용하면, React는 DOM을 바꾼 뒤에 effect 함수를 실행할 것입니다. Effects는 컴포넌트 안에 선언되어있기 때문에 props와 state에 접근할 수 있습니다. 기본적으로 React는 매 렌더링 이후에 effects를 실행합니다.

Effect를 "해제"할 필요가 있다면, 해제하는 함수를 반환해주면 됩니다. 이는 선택적입니다. 예를 들어, 이 컴포넌트는 친구의 접속 상태를 구독하는 effect를 사용했고, 구독을 해지함으로 써 해제해 줍니다.
useState와 마찬가지로 컴포넌트 내에서 여러 개의 effect를 사용할 수 있습니다. 

Hook을 사용하면 구독 추가하고 제거하는 로직과 같이 서로 관련 있는 코드들을 한가운데에 모아서 작성할 수 있습니다. 반면 class 컴포넌트에서는 생명주기 메서드를 각각 쪼개서 넣어야만 했습니다.

## Hook 사용 규칙
Hook은 그냥 JavaScript 함수지만 두가지 규칙을 준수해야 합니다.
1. 최상위에서만 Hook을 호출해야 합니다. 반복문, 조건문, 중첩된 함수 내에서 Hook을 실행하지 마세요.
2. React 함수 컴포넌트 내에서만 Hook을 호출해야 합니다. 일반 자바스크립트 함수에서는 Hook을 호출해서는 안됩니다.(커스텀훅은 예외)

이 규칙들을 강제하기 위해서 linter plugin을 제공하고 있습니다. 이 규칙들은 제약이 심하고 혼란스럽지만 제대로 동작하기 위해서는 필수적인 조건입니다.

### Hook이 use로 시작하는 이유는?
사용 규칙을 강제하기 위해 linter 플러그인을 사용하는데 이런 네이밍 컨벤션은 훅으로 인식하고 버그를 찾을 수 있게 해줍니다.

## 나만의 Hook 만들기
개발을 하다 보면 상태 관련 로직을 컴포넌트 간에 재사용하고 싶은 경우가 생깁니다. 이 문제를 해결하기 위해 전통적인 방법으로는 higher-order components와 render props가 바로 그것입니다. Custom Hook은 이들 둘과는 달리 컴포넌트 트리에 새 컴포넌트를 추가하지 않고도 이것을 가능하게 해줍니다.

각 컴포넌트의 state는 완전히 독립적입니다. Hook은 state 그 자체가 아니라, 상태 관련 로직을 재사용하는 방법입니다. 실제로 각각의 Hook 호출은 완전히 독립된 state를 가집니다. 그래서 심지어는 한 컴포넌트 안에서 같은 커스텀 훅을 두번 쓸 수도 있습니다.

커스텀 훅은 기능이라기보다는 컨벤션에 가깝습니다. 이름이 'use'로 시작하고, 안에서 다른 Hook을 호출한다면 그 함수를 custom Hook이라고 부를 수 있습니다. useSomething이라는 네이밍 컨벤션은 linter 플러그인이 Hook을 인식하고 버그를 찾을 수 있게 해줍니다.

## 다른 내장 Hook
보편적이지는 않지만 유용하다고 느낄만한 내장 Hook이 몇 가지 더 있습니다.
useContext는 컴포넌트를 중첩하지 않고도 React context를 구독할 수 있게 해줍니다.
그리고 useReducer는 복잡한 컴포넌트들의 state를 reducer로 관리할 수 있게 해줍니다.

# 요약
훅은 코드의 재사용 방법이며, 기존에 클래스 문법으로 작성된 불편하고 이해하기 어려웠던 로직을 단순화하고 상태 관련 코드를 관리하기 쉽게 만든 함수입니다. 내장 훅으로는 상태를 관리하는 useState, DOM 조작이나 비동기 로직에서 발생하는 사이드 이펙트를 처리하기 위한 useEffect가 내부 훅으로 존재하며, 상태 관련 로직을 재사용하고 싶을 때 커스텀 훅을 만들어서 사용하면 됩니다.


# 질문
## useState 내부 구조는?